---
title: QUIC协议与HTTP3.0
tags: TCP QUIC HTTP HTTP3.0
---



### 一、什么是QUIC协议
QUIC（Quick UDP Internet Connections，即快速UDP网络连接），是一个新的基于UDP的多路复用且安全的传输协议。QUIC完全运行于用户空间。最初由Google提出，目前已经被广泛应用于Google浏览器和Google服务器之间。目前Chorme、MicrosoftEdge、Firefox、Safari等主流浏览器均已经支持QUIC协议。
<img class="image image--xl" src="/assets/resource/docs/20190401-quic-http/20190401-quic-http-01.png"/>
如上图所示，QUIC协议=TCP+TLS+HTTP/2，QUIC增加了面向连接的TCP网络应用程序的性能，通过使用UDP在两个端点之间建立一系列多路复用（multiplexing） 的连接实现这个目的，它同时被用来代替TCP在网络层的作用。
QUIC虽然是基于UDP，但是在应用层做了类似TCP的可靠性保证，所以QUIC也是一个可靠的传输协议，但是仅仅可靠还远远不够，QUIC还提供安全方面的保证，这就是引入了类似于TLS的加密传输。

### 二、为什么需要QUIC协议
#### 1、TCP协议概要
传统架构上的网络应用开发，基本上都是在TCP（传输控制协议）和UDP（用户数据协议）之上二选一，这二者都基于IP协议开发，区别在于TCP提供面向字节流的可靠传输服务，而UDP则提供面向报文的尽力交付服务；二者相同之处在于都是基于IP协议实现的，在真正传输时，无论是TCP的数据块还是UDP报文都会被封装在一个IP分组的荷载中进行传输。

TCP 可靠传输原理：TCP通过序号、确认、重传来保证可靠传输。
<img class="image image--xl" src="/assets/resource/docs/20190401-quic-http/20190401-quic-http-02.png"/>
TCP端到端之间，采用缓冲区来暂存正在发送的数据，一旦数据发送出现问题（丢包导致的超时、冗余ACK等等），TCP发送端能够及时地从缓冲区中选择数据重发。
TCP为每一个TCP报文分配一个序号 seq = a，接收方接收到序号为a的报文，就响应一个ack = a + 1的ACK响应报文来确认，如果发生了丢包导致的计时器超时、收到冗余ACK，那么会触发重传机制，重发对应的数据包。

TCP的传输需要保证数据报按顺序来接收，如果发现接收顺序错误，就需要使用自动重传请求来通知发送方重新发送数据包，同时建立连接的三次握手在复杂的网络环境和地理限制也是一个重要的因素。由于TCP设计像一个"数据管道"，如果单个数据包有问题，后续的所有数据报的发送将会被阻塞。

#### 2、TCP协议存在的问题
##### 1）TCP连接耗时严重
基于TCP的HTTP链接，需要经过三次握手，这时候消耗掉一个RTT（发送一个数据包到收到对应的ACK，所花费的时间，如下图）。
<img class="image image--xl" src="/assets/resource/docs/20190401-quic-http/20190401-quic-http-03.png"/>
如上图所示，HTTPS在TCP的基础上，又使用了TLS1.2进行数据加密，需要消耗2个RTT，这样一来，在建立连接时，光是TCP + TLS过程就需要消耗掉3个RTT的时间，由于TCP的确认帧需要经过一个完整的RTT才可能被接收到，而TCP一个时刻发送的数据的数量会被拥塞窗口所限制。

##### 2）TCP重传的二义性
TCP协议采用序号来标记TCP发送的数据，当发送方发送seq = a的报文到接收端时，接收方会采用一个ack = a + 1的ACK报文来响应这个数据，当发送方接到这个ack = a + 1的应答报文时，就说明该帧被成功接收了。
<img class="image image--xl" src="/assets/resource/docs/20190401-quic-http/20190401-quic-http-04.png"/>
如上图所示，TCP在Initial阶段发出的帧序号为a，而经过一段时间之后，没有收到ACK，此时触发超时重传，过了一会儿收到了一个ACK帧，但是ACK帧的内容是a + 1，此时无法确认该a + 1是对initial send还是retry帧的确认（图左是对Retry的确认，图右是对Initial Retry的确认，但是到达的比较晚，已经触发了超时重传）。导致最终的超时时间（RTT）计算并不准，后续超时算法的迭代时间就会产生问题，比如触发超时重传的时间可能会不准。

##### 3）TCP队头堵塞的问题
由于TCP必须在一个请求的所有分片完成之后，才能将所有的数据提交给上层，所以TCP存在队头阻塞的问题。
<img class="image image--xl" src="/assets/resource/docs/20190401-quic-http/20190401-quic-http-05.png"/>
如上图所示缓冲区，如果3始终无法完成交付，那么会导致该TCP链接一直在处理3所述的应用层请求。
##### 4）网络切换时表现不佳
TCP的连接由一个四元组唯一确定，分别是源IP、目的IP、源端口和目的端口。
以经典的C/S模型来说，一般服务端的，也就是目的IP和目的端口是不会轻易发生变化的，但是客户端，也就是源IP和源端口可能会发生变更，考虑以下场景：
-   网络制式的切换，Wi-Fi到移动网络之间的切换是一个高发操作。
-   弱网环境下变换、移动网络中4G、3G、2G的切换等等，都会导致源IP和端口的变更。
-   NAT网关变动，这个是NAT端存在的变换状态，也会导致客户端IP的变化。

对于个TCP连接来说，如果四元组发生变化，则必须重新建立连接，再结合第一点说的，建立连接时的损耗，这样会导致整个传输效率下降很多。

##### 5）拥塞控制算法落后
TCP的拥塞控制算法主要是慢启动、拥塞避免、快速重传和快速恢复，这些算法虽然都很经典，但都是几十年前提出的，对于当时那种有线低速网络为主的环境很适用，但是随着科技的发展，现在基本都是无线高速网络为主，TCP这些拥塞算法不仅落伍，甚至还会带来副作用，导致网络阻塞更加严重。
TCP的拥塞算法以丢包作为拥塞控制的条件，这样做最大的弊端就在于，无法区分确实是因为网络阻塞导致的丢包，还是因为传输过程中的错误传输导致的（实际上此时网络并没有阻塞），如果是前者还好，减小发送端的发报数量，能起到一定作用；但如果是后者的场景，本来正常的一条网络通道，因为错误的算法控制变得更慢，这样就变得得不偿失。

### 三、QUIC协议介绍

#### 1、特点及优势
##### 1）0-RTT握手
TCP和TLS在握手时都有1个或多个RTT的损耗，而QUIC则只需要至多1个RTT的损耗，甚至只要不是首次建连，那么就是0-RTT；考虑一个场景：一个完整的请求，如果服务端处理耗时500ms（这算是个比较耗时的API了），一次RTT算100ms，用HTTPS（TCP+TLS）则需要3个RTT、那么总共耗时至少也要800ms，而用QUIC协议，则整个过程可能只需要600ms就可以完成，仅仅在握手这一个环节上，就提升了百分之20的性能，如下图所示：
<img class="image image--xl" src="/assets/resource/docs/20190401-quic-http/20190401-quic-http-06.png"/>

##### 2）解决重传二义性
重传二义性在上面TCP协议中已经讲过：由于无法区分ACK是对哪个报文的确认，也就没办法准确测量RTT。在QUIC协议中是如何解决二义性问题呢？QUIC中报文有Packet Number的概念，并且Packet Number是严格单调递增的，如下图所示：
<img class="image image--xl" src="/assets/resource/docs/20190401-quic-http/20190401-quic-http-07.png"/>
通过单调递增的Packet Number，可以轻松地分辨出ACK是对原始报文还是对重传报文的确认，因此也就可以得到较为准确的RTT测量值，避免重传二义性问题。

##### 3）解决队头阻塞
TCP中的队头阻塞的问题，根本原因是由于前面流丢包后导致信息不完整，进而影响后续数据流的读取和处理。在QUIC中，同样是复用一个连接，但是每个流之间都是相互独立的，换言之，某个流中的丢包，只会阻塞这个流本身，而不会阻塞整个连接，这样便解决了多路复用时的队头阻塞问题。
<img class="image image--xl" src="/assets/resource/docs/20190401-quic-http/20190401-quic-http-08.png"/>

##### 4）解决连接迁移
TCP连接是由四元组唯一确定的，也就是说如果其中某个元素发生变化后，这个连接就不能再使用，需要重新建立新的四元组TCP连接。而QUIC协议的连接，则是通过一个64位的随机数作为ID，也就是Connection ID，这样即使四元组发生了变化，只要ID不变，则连接也不会改变，也就不需要重连。

##### 5）改进的拥塞算法
虽然TCP的拥塞算法也在不断改进和优化，但是要想让这些优化措施生效，必须要操作系统层面支持才行，这样推行成本很高。QUIC协议对应用层实现不同的拥塞算法，比如说Cubic、BBR等算法。


#### 2、工作原理
上面一节提到了QUIC协议的一些改进点及优势，比如0-RTT、解决队头阻塞等，但都只是概念层面上的表述，现在就深入到QUIC的具体实现。
##### 1）包结构
传输的所有 QUIC 包以大小介于1至19字节的公共包头开始。公共包头的格式如下：
<img class="image image--xl" src="/assets/resource/docs/20190401-quic-http/20190401-quic-http-09.png"/>
QUIC公共包头主要包括：
-   Public flags（公共标识）：1字节
-   Connection ID（连接ID号）：1/4/8字节
-   QUIC Version（版本号）：4字节
-   Packet Number（包序列号）：1/2/4/6字节

##### 2）各字段详解
-   Public flags：该字段是必须的，主要用来补充说明后续包头的其它字段的，关键的几点：
0X01位如果设置为1，则表示报文是由客户端发送QUIC版本，如果设置为0，则表示是服务端接收客户端的QUIC版本协商。
0X02位如果设置为1，则表示这是一个公共的重置数据包。
0X08位如果设置为1，则表示Connection ID是完整的64bit。

-   Connection ID：连接的标示符，由于是64bit的无符号数，基本上可以唯一指定一个连接。
-   QUIC Version：表示QUIC的版本号，客户端提出想要使用的QUIC版本，如果服务端不支持这个版本，则会发送服务端支持的版本列表，但是这个报文不包含任何数据，仅仅是协商版本使用。
-   Packet Number：作为一个长度可变类似于Packet ID的字段，用来标示每一个包，并且要求是严格递增的。

##### 3）QUIC连接

##### 4）流量控制


### 四、HTTP 1.x与HTTP 2.x






### 五、QUIC与HTTP3.0



<br/>

参考资料：

[1]. https://quic.readthedocs.io/zh/latest/Packet%20Types%20and%20Formats.html

[2]. https://www.mesalab.cn/f/article/detail?id=65

[3]. https://juejin.cn/post/7085694620075556901

[4]. https://www.cnblogs.com/js68/p/14347830.html

[5]. https://hungryturbo.com/HTTP3-explained/quic/%E5%BC%95%E8%A8%80.html
